# app/api/v1/projects.py
import os
from fastapi import APIRouter, HTTPException, Depends, status
from pydantic import BaseModel
from typing import List, Dict, Any, Optional
from app.core import security
import json
import uuid
from pathlib import Path
from fastapi.responses import FileResponse
import requests
import logging

logger = logging.getLogger("projects_api")
logger.setLevel(logging.INFO)

router = APIRouter()

DATA_DIR = os.environ.get("BACKEND_DATA_DIR", "/Users/naveen/ai-docs-platform/backend/app/data")
TMP_DIR = os.environ.get("BACKEND_TMP_DIR", "/Users/naveen/ai-docs-platform/backend/tmp")

Path(DATA_DIR).mkdir(parents=True, exist_ok=True)
Path(TMP_DIR).mkdir(parents=True, exist_ok=True)

PROJECTS_FILE = os.path.join(DATA_DIR, "projects.json")

GEMINI_WORKER_URL = os.environ.get("GEMINI_WORKER_URL", "http://127.0.0.1:9000")
WORKER_TOKEN = os.environ.get("WORKER_TOKEN")  # optional

def _read_projects():
    try:
        with open(PROJECTS_FILE, "r") as f:
            return json.load(f)
    except Exception:
        return {}

def _write_projects(data):
    with open(PROJECTS_FILE, "w") as f:
        json.dump(data, f, indent=2)

class ProjectCreate(BaseModel):
    name: str

class ProjectOut(BaseModel):
    id: str
    name: str

@router.get("", response_model=List[ProjectOut])
def list_projects(current_user: Dict = Depends(security.get_current_user_from_token)):
    data = _read_projects()
    return [ {"id": k, "name": v["name"]} for k,v in data.items() ]

@router.post("", response_model=ProjectOut)
def create_project(payload: ProjectCreate, current_user: Dict = Depends(security.get_current_user_from_token)):
    data = _read_projects()
    pid = str(uuid.uuid4())
    sections = [
        {"id": str(uuid.uuid4()), "title": "Intro", "content": "Write your introduction here."}
    ]
    data[pid] = {"name": payload.name, "owner": current_user["user_id"], "sections": sections}
    _write_projects(data)
    return {"id": pid, "name": payload.name}

@router.get("/{project_id}/sections")
def get_sections(project_id: str, current_user: Dict = Depends(security.get_current_user_from_token)):
    data = _read_projects()
    project = data.get(project_id)
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    return project.get("sections", [])

@router.post("/{project_id}/generate")
def generate_project(project_id: str, payload: Dict = None, current_user: Dict = Depends(security.get_current_user_from_token)):
    """
    Generate a docx for the project.
    If a Gemini worker is available (GEMINI_WORKER_URL), POST to it and return its file_path.
    Otherwise fallback to local stub (same behavior as before).
    """
    data = _read_projects()
    project = data.get(project_id)
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")

    prompt = (payload or {}).get("prompt")
    sections = project.get("sections", [])

    # Try calling worker
    try:
        worker_url = os.environ.get("GEMINI_WORKER_URL")
        if worker_url:
            req_payload = {"project_id": project_id, "prompt": prompt, "sections": sections}
            headers = {"Content-Type": "application/json"}
            if WORKER_TOKEN:
                headers["Authorization"] = f"Bearer {WORKER_TOKEN}"
            resp = requests.post(f"{worker_url.rstrip('/')}/generate", json=req_payload, headers=headers, timeout=60)
            if resp.status_code == 200:
                j = resp.json()
                file_path = j.get("file_path")
                if file_path and os.path.exists(file_path):
                    return {"status": "ok", "file_path": file_path, "llm_used": True}
                # fall through to local fallback if worker returned no valid file
            else:
                logger.warning("Worker returned status %s: %s", resp.status_code, resp.text)
    except Exception as e:
        logger.exception("Worker call failed: %s", e)

    # Fallback local generation (same stub behaviour)
    out_lines = [project.get("name","Untitled"), ""]
    for s in sections:
        out_lines.append(s.get("title",""))
        out_lines.append(s.get("content",""))
        out_lines.append("")
    generated_text = "\n".join(out_lines)

    # Write to docx
    out_fname = f"{project_id}-{int(uuid.uuid4().int>>64)}.docx"
    out_path = os.path.join(TMP_DIR, out_fname)
    try:
        from docx import Document
        doc = Document()
        doc.add_heading(project.get("name","Document"), level=1)
        for para in generated_text.split("\n\n"):
            doc.add_paragraph(para.strip())
        doc.add_paragraph("\n\n---\nGenerated by backend fallback generation.")
        doc.save(out_path)
    except Exception:
        with open(out_path, "w") as f:
            f.write(generated_text)

    return {"status": "ok", "file_path": out_path, "llm_used": False}

@router.post("/{project_id}/export")
def export_project(project_id: str, payload: Dict = None, current_user: Dict = Depends(security.get_current_user_from_token)):
    fmt = (payload or {}).get("format", "docx")
    files = [f for f in os.listdir(TMP_DIR) if f.startswith(project_id) and f.endswith(f".{fmt}")]
    if not files:
        gen_res = generate_project(project_id, payload or {}, current_user=current_user)
        path = gen_res.get("file_path")
        if not path or not os.path.exists(path):
            raise HTTPException(status_code=500, detail="No export available")
        return {"file_path": path}
    files_full = sorted([os.path.join(TMP_DIR, f) for f in files], key=os.path.getmtime, reverse=True)
    path = files_full[0]
    if fmt == "docx":
        media_type = "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    elif fmt == "pptx":
        media_type = "application/vnd.openxmlformats-officedocument.presentationml.presentation"
    else:
        media_type = "application/octet-stream"
    return FileResponse(path, media_type=media_type, filename=os.path.basename(path))
